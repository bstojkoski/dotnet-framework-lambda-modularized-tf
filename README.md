# dotnet-todo

## Prerequisites
- Helm 3.x
- Minikube
- Docker

## Build and Run Docker Image

docker build -t dotnet-todo .
docker run -p 8080:80 dotnet-todo

## Deployment

1. Start Minikube:

    ```bash
    minikube start
    ```

2. Set up Docker to use Minikubeâ€™s Docker daemon:

    ```bash
    eval $(minikube docker-env)
    ```

3. Build and push your Docker image to ECR if not already done:

    ```bash
    aws ecr get-login-password --region eu-west-1 | docker login --username AWS --password-stdin 024848463067.dkr.ecr.eu-west-1.amazonaws.com
    docker build -t 024848463067.dkr.ecr.eu-west-1.amazonaws.com/dotnet-todo:20240805230843 .
    docker push 024848463067.dkr.ecr.eu-west-1.amazonaws.com/dotnet-todo:20240805230843
    ```

4. Deploy the Helm chart:

    ```bash
    helm install my-todo-app ./helm/dotnet-todo --values ./helm/dotnet-todo/values.yaml
    ```

5. Verify the deployment:

    ```bash
    kubectl get all
    ```

6. (Optional) To access the service via Minikube, use the following command:

    ```bash
    minikube service my-todo-app-dotnet-todo
    ```

## Configuration

The `values.yaml` file can be used to customize the deployment. Below are some of the configurable parameters:

- `image.repository`: Docker image repository
- `image.tag`: Docker image tag
- `replicaCount`: Number of replicas of the application
- `service.type`: Type of Kubernetes service (e.g., ClusterIP, NodePort, LoadBalancer)
- `service.port`: Service port
- `env`: Environment variables for the application
- `resources`: Resource requests and limits for the containers

## GitHub Actions Workflow: minikube-deploy.yaml
This GitHub Actions workflow is designed to deploy the dotnet-todo application using Minikube, a local Kubernetes cluster, and Helm.
The workflow is triggered by the completion of another workflow named "Run infrastructure and Deploy AWS Lambda."

Jobs and Steps
<span style="color:green">Checkout Code:</span>
Uses the actions/checkout@v2 action to clone the repository containing the code to the runner.

<span style="color:green">Set up AWS CLI:</span>
Configures the AWS CLI using the aws-actions/configure-aws-credentials@v2 action, enabling interaction with AWS resources.

<span style="color:green">Set up Minikube:</span>
Uses the manusa/actions-setup-minikube@v2.4.1 action to install and configure Minikube.

<span style="color:green">Set up Kubectl:</span>
Installs kubectl, the Kubernetes command-line tool, using the azure/setup-kubectl@v1 action.

<span style="color:green">Set up Helm:</span>
Installs Helm, a package manager for Kubernetes, using the azure/setup-helm@v1 action.

<span style="color:green">Create Kubernetes Secret for AWS ECR:</span>
Creates a Kubernetes secret to store Docker registry credentials for AWS ECR. This secret is used by Kubernetes to pull Docker images from the AWS ECR repository.

<span style="color:green">Deploy Helm Chart:</span>
Deploys the dotnet-todo application using a Helm chart. The Helm chart is configured using the values.yaml file located in the repo.

<span style="color:green">Wait for Pod to be Running:</span>
Checks the status of the deployed pods to ensure they are running. If the pods are not running, the job will continue, but the error will be logged.

<span style="color:green">Describe Deployment:</span>
Provides details about the deployment, useful for debugging and verification.

<span style="color:green">Get Pod Logs:</span>
Retrieves the logs from the application pod to help diagnose any issues with the deployment.

<span style="color:green">Verify Deployment:</span>
Lists all the Kubernetes resources created by the Helm deployment, such as pods, services, and deployments.

<span style="color:green">Describe Service:</span>
Describes the Kubernetes service that exposes the application to the network, providing details on how the application is accessible.

<span style="color:green">Download and Install ngrok:</span>
Downloads and installs ngrok, a tool that exposes local servers to the internet.

<span style="color:green">Authenticate ngrok:</span>
Authenticates ngrok using an authentication token stored in GitHub secrets.

<span style="color:green">Start kubectl Port-Forward:</span>
Sets up port forwarding from the Kubernetes service to localhost, making the application accessible via localhost.

<span style="color:green">Start ngrok:</span>
Starts ngrok to create a public URL that can be used to access the application from the internet.

<span style="color:green">Get ngrok URL:</span>
Retrieves the public URL generated by ngrok and stores it for later use.

<span style="color:green">Output ngrok URL:</span>
Outputs the ngrok URL, making it available for use in subsequent steps or for testing purposes.

<span style="color:green">Run Tests:</span>
Waits for the application to be fully up and running, then runs tests against the application endpoints to ensure it is functioning correctly.


## Test the GET endpoints

Test the app by calling the endpoints from a browser or Postman. The following steps are for Postman.

  Create a new HTTP request.
  Set the HTTP method to GET.
  Set the request URI to https://localhost:<port>/todoitems. For example, https://localhost:5001/todoitems.
  Select Send.

The call to GET /todoitems produces a response similar to the following:

```json
[
  {
    "id": 1,
    "name": "walk dog",
    "isComplete": false
  }
]
```

  Set the request URI to https://localhost:<port>/todoitems/1. For example, https://localhost:5001/todoitems/1.

  Select Send.

  The response is similar to the following:

```json
  {
    "id": 1,
    "name": "walk dog",
    "isComplete": false
  }
```

This app uses an in-memory database. If the app is restarted, the GET request doesn't return any data. If no data is returned, POST data to the app and try the GET request again.
